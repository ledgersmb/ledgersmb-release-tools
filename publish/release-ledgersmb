#!/usr/bin/ksh

#set -x
# automatically convert tag_release to upper case
typeset -u tag_release

URL="git@github.com:ledgersmb/LedgerSMB.git"
addn_URL=""
URL_docker="git@github.com:ledgersmb/ledgersmb-docker.git"
GH_api="https://api.github.com/repos"
#URL=/home/ehuelsmann/releases/lsmb-repo-2
branch=""
source_branch=""
release_version=""
new_dev_version=""
checkout_dir="LedgerSMB"
#release_key="8DA0AF10"
#release_key="39A629558DA0AF10"
release_key="B7626A90FA0F515B323C8F5C39A629558DA0AF10"
dl_base_dir="/www/vhosts/download.ledgersmb.org/public_html/f"
dl_tagged_dir="Releases"
dl_untagged_dir="Beta Releases"
pod_base_dir="/www/vhosts/docs.ledgersmb.org/public_html/perl-api"
tag_release="Y"
with_docker=""

help() {
    name=$(basename $0)
    cat - <<EOF
Usage:
   $name [options] <branch>[:<src-branch>] <version> <next-version>

Parameters:
  branch       The branch to create the release on
  src-branch   (optional) Branch with additional commits to include
  version      The version number of the release
  next-version The version to set on the release branch after release

Options:
  --addn-repo  Additional repo, in case <src-branch> is not in the main repo
  --debug      Runs the script in debugging mode (very, very verbose)
  --force-accept-version-update
  --with-*     Enable feature '*'
  --without-*  Disable feature '*'

Features:
  docker       Publishes docker images
               Tagged releases include this option; others don't

EOF
}

process_arguments() {

    stop_processing=
    while [[ $# -ne 0 && -z "$stop_processing" ]]
    do
        case "$1" in
            --addn-repo)
                addn_URL="$2"
                shift 2
                ;;
            --debug)
                debug_script=yes
                shift
                ;;
            --force-accept-version-update)
                force_accept_version_update=yes
                shift
                ;;
            --with-*)
                option=${1#--with-}
                shift
                case "$option" in
                    docker)
                        with_docker="yes"
                        ;;
                    *)
                        echo "Unrecognized option '$option'"
                        exit 1
                        ;;
                esac
                ;;
            --without-*)
                option=${1#--without-}
                shift
                case "$option" in
                    docker)
                        with_docker="no"
                        ;;
                    *)
                        echo "Unrecognized option '$option'"
                        exit 1
                        ;;
                esac
                ;;
            --*)
                echo "Error: unknown script argument $1"
                exit
                ;;
            *)
                stop_processing="yes"
                ;;
        esac
    done

    if [[ $# -eq 3 ]]
    then
        branch="$1"
        release_version="$2"
        new_dev_version="$3"
    else
        echo "Error: Incorrect number of arguments: $# found, 3 expected"
        help
        exit 1
    fi
    if [[ "$branch" == *":"* ]]
    then
        source_branch=${branch#*:}
        branch=${branch%:*}
    else
        source_branch="$branch"
    fi
}

load_configuration() {
    if [[ ! -f ~/.lsmb-github-releases ]]; then
        fail "Missing configuration file ~/.lsmb-github-releases!"
    else
        source ~/.lsmb-github-releases

        [[ -n "$github_user" ]] || fail "variable 'github_user' not defined! please define in ~/.lsmb-github-releases"
        [[ -n "$github_token" ]] || fail "variable 'github_token' not defined! please define in ~/.lsmb-github-releases"
    fi

    if [[ -n $(echo "$release_version" | grep -- "-") ]]; then
        echo "Version modifier detected (rc/beta/...).
Modified versions don't get tagged. Force tag? [y/N]"
        read tag_release
    fi

    if [[ "$tag_release" == "Y" && -z "$with_docker" ]]
    then
        with_docker="yes"
    fi
}


fail() {
   echo -e "$1\n" >&2
   exit 1
}

verify_dependency() {
   which_executable=$(which $1)
   eval $1="$which_executable"
   if [[ -z "$which_executable" ]]; then
      fail "Missing dependency: $1"
   fi
}

verify_dependencies() {
   verify_dependency "find"
   verify_dependency "gpg"
   verify_dependency "git"
   verify_dependency "sed"
   verify_dependency "grep"
   verify_dependency "tar"
   verify_dependency "perl"
   verify_dependency "mktemp"
   verify_dependency "less"
   verify_dependency "gzip"
   verify_dependency "awk"
   verify_dependency "sha256sum"
   verify_dependency "scp"
   verify_dependency "sftp"
   verify_dependency "sudo"
   verify_dependency "tx"
   verify_dependency "make"
   verify_dependency "msgmerge"
   verify_dependency "msguniq"
   verify_dependency "curl"
   verify_dependency "jq"
   verify_dependency "cat"
   verify_dependency "date"
   verify_dependency "createdb"
   verify_dependency "postgresql_autodoc"
   verify_dependency "psql"
   verify_dependency "uuid"
   verify_dependency "docker"
}

verify_release_key() {
   if [[ -z $($gpg --list-secret-keys "$release_key") ]] ; then
     fail "No key with ID '$release_key' (release key) available!"
   fi
}

failure_cleanup() {
    rm -rf "$our_workspace"
    rm -rf "$docker_workspace"
    if [[ -n "$upload_staging" ]]
    then
        echo "cd '$upload_staging'
-rm 'ledgersmb-$release_version.tar.gz.asc'
-rm 'ledgersmb-$release_version.tar.gz'
cd ..
rmdir '$upload_staging'
" | $sftp -b - "lsmb-uploader@download.ledgersmb.org"
    fi
}

setup_workspace() {
   our_workspace=$($mktemp -d)
   docker_workspace=$($mktemp -d)
   trap "failure_cleanup" TERM EXIT
}

populate_workspace() {
    trap 'fail "Failed to check out branch ''$branch'' from ''$URL''!"' ERR

    olddir=$PWD
    cd $our_workspace
    $git clone --recursive --depth=50 --single-branch \
         --branch "$branch" "$URL" "$checkout_dir"

    if [[ -n "$addn_URL" || "$branch" != "$source_branch" ]]
    then
        trap 'fail "Failed to pull ''$source_branch'' from ''$addn_URL''"' ERR

        [[ -z "$addn_URL" ]] && addn_URL="$URL"
        cd "$checkout_dir"
        $git remote add alt "$addn_URL"
        $git pull --ff-only alt "$source_branch"
    fi

    trap 'fail "Failed to check out branch ''$branch'' from ''$URL''!"' ERR
    cd $olddir

    if test -e "$our_workspace/$checkout_dir/LedgerSMB.pm" ;
    then
        LedgerSMBpm_path="LedgerSMB.pm"
    else
        LedgerSMBpm_path="lib/LedgerSMB.pm"
    fi
    echo "LedgerSMB.pm found at $LedgerSMBpm_path"
}

populate_docker_workspace() {
  ( cd $docker_workspace && \
    $git clone --recursive --single-branch --branch "$branch" "$URL_docker" "$docker_workspace/docker") \
  || fail "Failed to check out (docker) branch '$branch' from '$docker_URL'!"
}

update_database_schema() {
    (cd "$our_workspace/$checkout_dir" && \
     $sudo -u postgres $psql -c "drop database if exists ledgersmb" && \
     $sudo -u postgres $createdb ledgersmb && \
     $sudo -u postgres $psql -c "alter role postgres password 'postgres'" && \
     $sudo -u postgres $psql -d ledgersmb < sql/Pg-database.sql && \
     ( for script in $($grep -vE '^#|^$' sql/changes/LOADORDER | $sed -e 's/!//') ; do $sudo -u postgres psql -d ledgersmb < sql/changes/$script ; done ) && \
     ( for script in $($grep -vE '^#|^$' sql/modules/LOADORDER | $sed -e 's/!//') ; do sudo -u postgres $psql -d ledgersmb < sql/modules/$script ; done ) && \
     ( cd doc/database && \
       $postgresql_autodoc -h localhost -d ledgersmb -U postgres --password=postgres ) && \
     $git add --all doc/database && $git commit -m "* Automated release schema update" ) \
    || fail "Failed to update database schema documentation"
}

update_translations() {
   (cd "$our_workspace/$checkout_dir" && \
    $tx pull -f -a && utils/devel/rebuild_pot.sh && \
    ($find . -name '*~' -exec rm '{}' + ) && \
    ($find . -name '*.orig' -exec rm '{}' + ) && \
    $git add --all locale && $git commit -m "* Automated release language update" ) \
   || fail "Failed to update branch ($branch) translations"
}

update_dockerfile() {
   (cd "$docker_workspace/docker" && \
    $sed -i -e "s/^ENV LSMB_VERSION .*\$/ENV LSMB_VERSION $release_version/
                s/^ARG LSMB_VERSION=.*\$/ARG LSMB_VERSION=\"$release_version\"/
                s/^ARG LSMB_DL_DIR=.*\$/ARG LSMB_DL_DIR=\"$prj_sub_dir\"/ " Dockerfile && \
    $git commit -a -m "* Automatic Dockerfile update by release process" && \
    $git tag "$release_version") \
   || fail "Failed to update Dockerfile!"
}

detect_current_version() {
   current_version=$(
     cd "$our_workspace/$checkout_dir"
     $sed -ne "/^our \$VERSION/ {
  s/^our \$VERSION = '\\(.*\\)';\$/\\1/
  p
}" "$LedgerSMBpm_path" )
   if [[ -z "$current_version" ]] ; then
     fail "Failed to detect current version!"
   fi
}

version_to_regex() {
   echo "$1" | $sed 's/\./\\./g'
}

detect_versionpatch_files() {
   versionpatch_regex=$(version_to_regex "$current_version")
   versionpatch_files=$(grep -lRE "$versionpatch_regex" "$our_workspace/$checkout_dir" | grep -v Changelog | grep -v sql/changes/)
   if [[ -z "$versionpatch_regex" || -z "$versionpatch_files" ]]; then
     fail "Failed to detect which files to patch for version update!"
   fi
}

patch_version() {
   version_regex=$(version_to_regex "$1")
   new_version=$2
   $sed -i -e "s/$version_regex/$new_version/" $versionpatch_files \
   || fail "Failed to patch files for version update!"
   $sed -i -e "s/\"Project-Id-Version:.*/\"Project-Id-Version: LedgerSMB $new_version\\\\n\"/" "$our_workspace/$checkout_dir/locale/po"/*.po \
   || fail "Failed to patch PO files for version update!"
}

show_release_parameters() {
clear
echo "
Please review details below!
Continuing will commit the diff shown and create a new version tag!


Release details
Git URL: $URL
Branch: $branch
Current version: $current_version
To be released: $release_version
Force-accept version update: $force_accept_version_update

Git config used for tag:
$($git config --list | $grep -E 'user.(email|name)')

Patched files:
$(echo "$versionpatch_files" | $sed -e "s#$our_workspace/$checkout_dir/##g")

Patch diff:
$(cd "$our_workspace/$checkout_dir" && $git diff )
" | $less

}

commit_versionupdate() {
   (cd "$our_workspace/$checkout_dir" && \
    $git commit -am "Update version$1" ) \
   || [[ -n "$force_accept_version_update" ]] \
   || fail "Failed to commit version update patch!"
}

commit_versiontag() {
   (cd "$our_workspace/$checkout_dir" && \
    $git tag -m "$release_version" "$release_version" ) \
   || fail "Failed to tag version $release_version!"
}

create_versiontarball() {
   (cd "$our_workspace/$checkout_dir" && \
    $git checkout "$release_version" && \
    $make dist DIST_DIR=../ DIST_VER=$release_version ) \
   || fail "Failed to create release archive!"
}

sign_versiontarball() {
   echo -n "Signing ledgersmb-$release_version.tar.gz\n"
   $gpg -u "$release_key" \
        -a -b "$our_workspace/ledgersmb-$release_version.tar.gz" \
   || fail "Failed to sign release archive!"
   echo "Succesfully signed release archive; directory content:

$(ls -lh "$our_workspace")
"
}

build_pod() {
    (cd "$our_workspace/$checkout_dir" && \
     $make pod) \
    || fail "Failed to build Perl API docs!"
}

build_docker_images() {
    (cd "$docker_workspace/docker" && \
     $sudo $docker build --build-arg "ARTIFACT_LOCATION=$staged_artifact" -t ledgersmb/ledgersmb:$branch . ) \
    || fail "Failed to build docker images"
}

update_remote() {
   (cd "$our_workspace/$checkout_dir" && \
    $git push --follow-tags origin "$branch" ) \
   || fail "Failed to update the origin repository!"
}

update_docker_remote() {
   (cd "$docker_workspace/docker" && \
    $git push --tags origin "$branch" ) \
   || fail "Failed to update remote docker repository!"
}

stage_files_dl() {
    (cd "$our_workspace" && \
     echo "mkdir '$upload_staging'
cd '$upload_staging'
put 'ledgersmb-$release_version.tar.gz.asc'
put 'ledgersmb-$release_version.tar.gz'
" | $sftp -b - "lsmb-uploader@download.ledgersmb.org") \
     || fail "Failed to upload files to download.ledgersmb.org!"
}

publish_docker_images() {
    ($sudo $docker login &&
     $docker image tag ledgersmb/ledgersmb:$branch ledgersmb/ledgersmb:$release_version && \
     ([[ "$branch" != "$(cd "$docker_workspace/docker"; $git remote show origin | $awk '/HEAD branch/ {print $NF}' )" ]] \
      || $docker image tag ledgersmb/ledgersmb:$branch ledgersmb/ledgersmb:latest ) && \
     $sudo $docker image push ledgersmb/ledgersmb:$branch && \
     $sudo $docker image push ledgersmb/ledgersmb:$release_version && \
     ([[ "$branch" != "$(cd "$docker_workspace/docker"; $git remote show origin | $awk '/HEAD branch/ {print $NF}' )" ]] \
      || $sudo $docker image push ledgersmb/ledgersmb:latest)
    ) \
    || fail "Failed to publish docker images"
}

publish_files_dl() {
    (cd "$our_workspace" && \
     echo "cd '$dl_base_dir/$prj_sub_dir'
mkdir '$release_version'
cd '$release_version'
rename '$upload_staging/ledgersmb-$release_version.tar.gz.asc' './ledgersmb-$release_version.tar.gz.asc'
rename '$upload_staging/ledgersmb-$release_version.tar.gz' './ledgersmb-$release_version.tar.gz'
rmdir '$upload_staging'
" | $sftp -b - "lsmb-uploader@download.ledgersmb.org") \
     || fail "Failed to upload files to download.ledgersmb.org!"
}

publish_files_gh() {
   gh_auth="-u $github_user:$github_token"
   (cd "$our_workspace" && \
    $curl -X POST $gh_auth "$GH_api/ledgersmb/LedgerSMB/releases" \
          -d "{\"tag_name\": \"$release_version\", \"name\": \"$release_version\", \"draft\": false, \"body\": \"todo\", \"name\": \"\"}" \
       > release_create_response) \
   || fail "Failed to create GitHub release!"
   upload_url=$($jq -M -r '.upload_url' < $our_workspace/release_create_response | $sed -e 's/{.*//')
   $curl -X POST -H 'Content-Type: text/plain' $gh_auth \
         "$upload_url?name=ledgersmb-$release_version.tar.gz.asc" \
         -T $our_workspace/ledgersmb-$release_version.tar.gz.asc \
   || fail "Failed to upload signature file to GitHub!"
l   $curl -X POST -H 'Content-Type: application/x-tar' $gh_auth \
         "$upload_url?name=ledgersmb-$release_version.tar.gz" \
         -T $our_workspace/ledgersmb-$release_version.tar.gz \
   || fail "Failed to upload tarball to GitHub!"
}


extract_changelog_internal() {
   extract_version=${1:-$release_version}
   escaped_version=$(echo "$extract_version" | $sed -e 's/\./\./g')
   extracted_changelog=$(cd "$our_workspace/$checkout_dir" && \
     $awk "
BEGIN {
   matched=0;
   printing=0;
}
/Changelog for/ {
   printing=0;
}
/Changelog for $escaped_version/ {
   if(!matched) {
       matched=1;
       printing=1;
   }
}
{
   if (printing) {
       print;
   }
}" Changelog)
}

extract_changelog() {
   extract_changelog_internal

   if [[ -z $extracted_changelog && \
         -n $(echo "$release_version" | $grep -- "-rc") ]] ; then
     extract_changelog_internal $(echo "$release_version" | $sed -e 's/-rc.*//')
  fi
}

extract_sha256sum() {
   extracted_sha256sums=$(cd "$our_workspace" && \
     $sha256sum ledgersmb-$release_version.tar.gz* )
}

upload_pod() {
    (cd "$our_workspace/$checkout_dir" && \
         $scp -q -r UI/pod/ \
              lsmb-uploader@docs.ledgersmb.org:$pod_base_dir/$release_version/ ) \
        || fail "Failed to upload Perl API docs!"
}


process_arguments "$@"
load_configuration
verify_dependencies

if [[ -n "$debug_script" ]]
then
    set -x
fi

verify_release_key
setup_workspace
populate_workspace
populate_docker_workspace

if [[ -z $(echo "$release_version" | grep -- "-") ]]; then
    prj_sub_dir="$dl_tagged_dir"
else
    prj_sub_dir="$dl_untagged_dir"
fi
if [[ -z "$(cd "$our_workspace/$checkout_dir"; $git tag | grep -E "^$release_version$")" ]]
then

  if [[ "$release_version" == "$branch.0" ]]; then
    update_database_schema
  fi

  update_translations
  if [[ "$with_docker" == "yes" ]]; then
    update_dockerfile
  fi
  detect_current_version
  detect_versionpatch_files
  patch_version "$current_version" "$release_version"

  show_release_parameters
  commit_versionupdate
  commit_versiontag
  patch_version "$release_version" "$new_dev_version"
  commit_versionupdate '

[skip ci]'
else
  tag_release="N"
fi

create_versiontarball
sign_versiontarball
extract_changelog
extract_sha256sum
build_pod

staging_uuid=$($uuid)
upload_staging="$dl_base_dir/../staging/$staging_uuid"
stage_files_dl

staged_artifact="https://download.ledgersmb.org/staging/$staging_uuid/ledgersmb-$release_version.tar.gz"
if [[ "$with_docker" == "yes" ]]; then
    build_docker_images
fi

# We have the signed binaries now and are about to publish;
# if anything goes wrong beyond this point, we need the
# binaries to restart the process "by hand" or even to
# execute it by hand
trap - TERM EXIT

typeset -u yn
echo -n "Ready to publish $release_version now. Proceed? [y/N] "
read yn
if [[ "$yn" != "Y" ]]; then

    $cat - <<-EOF
	Release artifacts left:

	  LedgerSMB workspace: $our_workspace
	  Docker workspace:    $docker_workspace
	  Upload staging area: ${upload_staging:-(none)}
	EOF
    fail "Aborted by user!"
fi

if [[ "$tag_release" == "Y" ]]; then
    echo "Pushing changes to repository"
    update_remote
fi
if [[ "$with_docker" == "yes" ]]
then
    echo "Pushing docker updates"
    update_docker_remote
fi


# only after we published to 'download.ledgersmb.org',
# update the docker files so they can download
staging_dir=$(uuid)
stage_files_dl

if [[ "$tag_release" == "Y" ]]; then
    echo "Uploading POD documentation"
    upload_pod

    # we can't upload to GitHub if there's no tag...
    echo "Updating GitHub tag with attachments"
    publish_files_gh
fi
if [[ "$with_docker" == "yes" ]]
then
    echo "Uploading Docker images"
    publish_docker_images
fi

prj_url_dir=$(echo "$prj_sub_dir" | sed -e 's/ /%20/g')
publish_files_dl


clear

echo "
release_branch=$branch
release_version=$release_version
release_date=$($date --iso --utc)
" > ~/ledgersmb-release-parameters

$cat <<EOT >> ~/ledgersmb-$branch-release-parameters
release_sha256sums="\$($cat <<'EOF'
$extracted_sha256sums
EOF
)"

release_changelog="\$($cat <<'EOF'
$extracted_changelog
EOF
)"
EOT

rm -rf "$our_workspace"
rm -rf "$docker_workspace"

exit 0
